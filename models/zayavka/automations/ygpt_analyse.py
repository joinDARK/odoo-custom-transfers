"""
YandexGPT –∞–Ω–∞–ª–∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∑–∞—è–≤–æ–∫

–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å:
1. –ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —Å –ø–æ–º–æ—â—å—é Yandex Vision OCR + YandexGPT
2. –ê–Ω–∞–ª–∏–∑ Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ (–Ω–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å):
   - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ñ–æ—Ä–º–∞—Ç–æ–≤: .xlsx, .xls, .xlsm, .csv
   - –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –≤—Å–µ—Ö –ª–∏—Å—Ç–æ–≤ –∏ —è—á–µ–µ–∫
   - –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
   - –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å YandexGPT (–æ—Ç–∫–ª—é—á–µ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Excel –∞–Ω–∞–ª–∏–∑–∞:
- action_test_excel_analysis() - –∑–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
- analyze_excel_documents() - –æ—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –∞–Ω–∞–ª–∏–∑–∞
- get_excel_attachments() - –ø–æ–∏—Å–∫ Excel —Ñ–∞–π–ª–æ–≤ –≤–æ –≤–ª–æ–∂–µ–Ω–∏—è—Ö
"""

import requests
import logging
import base64
import json
import pandas as pd
import io
# import os
from odoo import models, api

_logger = logging.getLogger(__name__)

API_KEY = os.environ.get('YANDEX_API_KEY', '')
FOLDER_ID = 'b1gutoi9c7ngrfbtd6cl'
URL = 'https://llm.api.cloud.yandex.net/foundationModels/v1/completion'
OCR_URL = 'https://ocr.api.cloud.yandex.net/ocr/v1/recognizeText'
PROMPT = """
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –¥–æ–∫—É–º–µ–Ω—Ç –∏ –≤—ã–¥–∞–π –º–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é

—Å—É–º–º–∞
–≤–∞–ª—é—Ç–∞
–∫—Ç–æ –ø–ª–∞—Ç–∏—Ç
–∫–æ–º—É –ø–ª–∞—Ç—è—Ç
—Å—Ç—Ä–∞–Ω–∞ –ø–æ–ª—É—á–∞—Ç–µ–ª—è
—Å–≤–∏—Ñ—Ç –∫–æ–¥
–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
–Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏ (application number)
–¥–∞—Ç–∞ –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–∫–∏

–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤—å –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ –≤—ã–¥–∞–π –º–Ω–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ —Ñ–æ—Ä–º–∞—Ç–µ json

—Å—É–º–º–∞ - amount
–≤–∞–ª—é—Ç–∞ - currency
–∫—Ç–æ –ø–ª–∞—Ç–∏—Ç - subagent_payer_ids
–∫–æ–º—É –ø–ª–∞—Ç—è—Ç - exporter_importer_name
—Å—Ç—Ä–∞–Ω–∞ –ø–æ–ª—É—á–∞—Ç–µ–ª—è - country_id
—Å–≤–∏—Ñ—Ç –∫–æ–¥ - bank_swift
–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ - payment_purpose
–Ω–æ–º–µ—Ä –∑–∞—è–≤–∫–∏ - application_sequence
–¥–∞—Ç–∞ –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–∫–∏ - payment_date

–≤—ã–¥–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—É—é –≤–∞–ª—é—Ç—É –±–µ–∑ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–∞
–µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ, —Ç–æ –æ—Å—Ç–∞–≤–ª—è–π –ø—É—Å—Ç–æ—Ç—É
"""
UPDATE_FIELDS = [
    'amount',
    'currency', 
    'subagent_payer_ids',
    'subagent_ids',
    'exporter_importer_name',
    'country_id',
    'bank_swift',
    'payment_purpose',
    'application_sequence',
    'payment_date',
]

# –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å: –ê–Ω–∞–ª–∏–∑ Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
# –î–æ—Å—Ç—É–ø–Ω—ã–µ –º–µ—Ç–æ–¥—ã:
# - get_excel_attachments() - –ø–æ–∏—Å–∫ Excel —Ñ–∞–π–ª–æ–≤ –≤–æ –≤—Å–µ—Ö –ø–æ–ª—è—Ö –≤–ª–æ–∂–µ–Ω–∏–π
# - analyze_excel_documents() - –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ Excel —Ñ–∞–π–ª–æ–≤ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
# - action_test_excel_analysis() - —Ç–µ—Å—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–Ω–∞–ª–∏–∑–∞
# –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: .xlsx, .xls, .xlsm, .csv


class ZayavkaYandexGPTAnalyse(models.Model):
    _inherit = 'amanat.zayavka'

    def action_analyse_with_yandex_gpt(self):
        self._get_yandex_gpt_config()

    def action_test_excel_analysis(self):
        """
        –¢–µ—Å—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
        """
        try:
            _logger.info("üöÄ –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê EXCEL –î–û–ö–£–ú–ï–ù–¢–û–í")
            _logger.info(f"üìã –ó–∞—è–≤–∫–∞: {self.zayavka_id}")
            _logger.info("üìä –≠—Ç–∞–ø—ã: 1) –ü–æ–∏—Å–∫ Excel —Ñ–∞–π–ª–æ–≤ -> 2) –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ -> 3) –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∞–ª–∏–∑ Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
            results = self.analyze_excel_documents()
            
            if results:
                _logger.info(f"üéâ –¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù –£–°–ü–ï–®–ù–û: –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {len(results)} Excel —Ñ–∞–π–ª–æ–≤")
                _logger.info("üìã –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–í–û–î–ö–ê:")
                for i, result in enumerate(results, 1):
                    _logger.info(f"  ‚úÖ {i}. {result['file_name']}")
                    _logger.info(f"     üìÇ –ü–æ–ª–µ: {result['field_name']}")
                    _logger.info(f"     üìÑ –†–∞–∑–º–µ—Ä: {result['file_size']} –±–∞–π—Ç")
                    _logger.info(f"     üìä –ò–∑–≤–ª–µ—á–µ–Ω–æ: {result['text_length']} —Å–∏–º–≤–æ–ª–æ–≤")
                _logger.info("üéØ –í—Å–µ Excel —Ñ–∞–π–ª—ã –ø—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏!")
            else:
                _logger.info("‚ÑπÔ∏è –¢–ï–°–¢: –ù–µ –Ω–∞–π–¥–µ–Ω–æ Excel —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –∞–Ω–∞–ª–∏–∑–∞ Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {str(e)}")

    def action_test_screen_sber_ocr(self):
        """
        –¢–µ—Å—Ç–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π screen_sber: OCR + YandexGPT + –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π
        """
        try:
            _logger.info("üöÄ –ó–∞–ø—É—Å–∫ –ü–û–õ–ù–û–ì–û –ê–ù–ê–õ–ò–ó–ê –¥–ª—è screen_sber_attachments")
            _logger.info("üìã –≠—Ç–∞–ø—ã: 1) OCR —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ -> 2) YandexGPT –∞–Ω–∞–ª–∏–∑ -> 3) –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π –∑–∞—è–≤–∫–∏")
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (—Ç–µ–ø–µ—Ä—å —Å –ø–æ–ª–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π)
            results = self.analyze_screen_sber_images_with_yandex_gpt()
            
            if results:
                _logger.info(f"–¢–ï–°–¢ –ó–ê–í–ï–†–®–ï–ù: –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {len(results)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")
                _logger.info("üìã –°–í–û–î–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í:")
                for i, result in enumerate(results, 1):
                    _logger.info(f"  {i}. {result['image_name']}")
                    _logger.info(f"     –î–ª–∏–Ω–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞: {len(result['recognized_text'])} —Å–∏–º–≤–æ–ª–æ–≤")
                    _logger.info(f"     –ü–µ—Ä–≤—ã–µ 100 —Å–∏–º–≤–æ–ª–æ–≤: {result['recognized_text'][:100]}...")
                _logger.info("‚úÖ –í—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏ –∞–Ω–∞–ª–∏–∑–∞!")
            else:
                _logger.info("‚ùå –¢–ï–°–¢: –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–µ–∫—Å—Ç –Ω–∏ –∏–∑ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ screen_sber: {str(e)}")

    @api.model
    def _get_yandex_gpt_config(self):
        headers = {
            "Authorization": f"Api-Key {API_KEY}",
            "Content-Type": "application/json",
            "X-Folder-Id": FOLDER_ID
        }

        data = {
            "modelUri": f"gpt://{FOLDER_ID}/yandexgpt/latest",  # –∏–ª–∏ rc/pro/lite, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            "completionOptions": {
                "stream": False,
                "temperature": 0.3,
                "maxTokens": "1000"
            },
            "messages": [
                {"role": "system", "text": "–¢—ã —É–º–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –ì–æ–≤–æ—Ä–∏ –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ–Ω—è—Ç–Ω–æ."},
                {"role": "user", "text": "–û–±—ä—è—Å–Ω–∏ –ø—Ä–∏–Ω—Ü–∏–ø —Ä–∞–±–æ—Ç—ã –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏ –ø—Ä–æ—Å—Ç—ã–º —è–∑—ã–∫–æ–º."}
            ]
        }

        return headers, data

    def analyze_document_with_yandex_gpt(self, document_json):
        """
        –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç JSON –¥–æ–∫—É–º–µ–Ω—Ç–∞ —Å –ø–æ–º–æ—â—å—é YandexGPT
        """
        try:
            headers = {
                "Authorization": f"Api-Key {API_KEY}",
                "Content-Type": "application/json",
                "X-Folder-Id": FOLDER_ID
            }

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å JSON –¥–æ–∫—É–º–µ–Ω—Ç–∞
            user_message = f"–î–æ–∫—É–º–µ–Ω—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:\n{document_json}"

            data = {
                "modelUri": f"gpt://{FOLDER_ID}/yandexgpt/latest",
                "completionOptions": {
                    "stream": False,
                    "temperature": 0.3,
                    "maxTokens": "2000"
                },
                "messages": [
                    {"role": "system", "text": PROMPT},
                    {"role": "user", "text": user_message}
                ]
            }

            response = requests.post(URL, headers=headers, json=data, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
                if 'result' in result and 'alternatives' in result['result']:
                    alternatives = result['result']['alternatives']
                    if alternatives and len(alternatives) > 0:
                        gpt_response = alternatives[0]['message']['text']
                        
                        # –í—ã–≤–æ–¥–∏–º –æ—Ç–≤–µ—Ç –Ω–µ–π—Ä–æ–Ω–∫–∏ –≤ –ª–æ–≥–µ—Ä
                        _logger.info(f"ü§ñ YandexGPT –ê–ù–ê–õ–ò–ó –î–û–ö–£–ú–ï–ù–¢–ê –¥–ª—è –∑–∞—è–≤–∫–∏ {self.zayavka_id}:\n{gpt_response}")
                        
                        # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è –∑–∞—è–≤–∫–∏
                        self._update_fields_from_gpt_response(gpt_response)
                        
                        return gpt_response
                else:
                    _logger.warning(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç YandexGPT: {result}")
            else:
                _logger.error(f"–û—à–∏–±–∫–∞ API YandexGPT: {response.status_code} - {response.text}")
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ —Å YandexGPT: {str(e)}")
            
        return None

    def _update_fields_from_gpt_response(self, gpt_response):
        """
        –ü–∞—Ä—Å–∏—Ç –æ—Ç–≤–µ—Ç YandexGPT –∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø–æ–ª—è –∑–∞—è–≤–∫–∏
        """
        try:
            import json
            import re
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º JSON –∏–∑ –æ—Ç–≤–µ—Ç–∞ (–∏—â–µ–º –±–ª–æ–∫ –º–µ–∂–¥—É ``` –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ JSON)
            json_match = re.search(r'```(?:json)?\s*(\{.*?\})\s*```', gpt_response, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                # –ï—Å–ª–∏ –Ω–µ—Ç –±–ª–æ–∫–∞ –∫–æ–¥–∞, –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ JSON –≤ —Ç–µ–∫—Å—Ç–µ
                json_match = re.search(r'\{.*?\}', gpt_response, re.DOTALL)
                if json_match:
                    json_str = json_match.group(0)
                else:
                    _logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ JSON –≤ –æ—Ç–≤–µ—Ç–µ YandexGPT: {gpt_response}")
                    return

            # –ü–∞—Ä—Å–∏–º JSON
            try:
                parsed_data = json.loads(json_str)
            except json.JSONDecodeError as e:
                _logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –∏–∑ –æ—Ç–≤–µ—Ç–∞ YandexGPT: {e}\nJSON: {json_str}")
                return

            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            update_values = {}
            
            # –ú–∞–ø–ø–∏–Ω–≥ –ø–æ–ª–µ–π –∏–∑ JSON –≤ –ø–æ–ª—è –º–æ–¥–µ–ª–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –ø–æ–ª—è –∏–∑ zayavka.py)
            field_mapping = {
                'amount': 'amount',  # –°—É–º–º–∞ –∑–∞—è–≤–∫–∏ (—Å—Ç—Ä–æ–∫–∞ 965)
                'currency': 'currency',  # –í–∞–ª—é—Ç–∞ (—Å—Ç—Ä–æ–∫–∞ 895)
                'subagent_payer_ids': None,  # –≠—Ç–æ Many2many –ø–æ–ª–µ –∫ amanat.payer, –æ–±—Ä–∞–±–æ—Ç–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ
                'exporter_importer_name': 'exporter_importer_name',  # –ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è/–ø—Ä–æ–¥–∞–≤—Ü–∞ (—Å—Ç—Ä–æ–∫–∞ 82)
                'country_id': None,  # –≠—Ç–æ Many2one –ø–æ–ª–µ, –æ–±—Ä–∞–±–æ—Ç–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω–æ  
                'bank_swift': 'bank_swift',  # SWIFT –∫–æ–¥ –±–∞–Ω–∫–∞ (—Å—Ç—Ä–æ–∫–∞ 84)
                'payment_purpose': 'payment_purpose',  # –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ (—Å—Ç—Ä–æ–∫–∞ 1214)
                'application_sequence': 'application_sequence',  # –ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∑–∞—è–≤–ª–µ–Ω–∏—è (—Å—Ç—Ä–æ–∫–∞ 1228)
                'payment_date': 'payment_date',  # –î–∞—Ç–∞ –ø–ª–∞—Ç–µ–∂–∞ - –Ω—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø–æ–ª–µ
            }
            
            for json_key, model_field in field_mapping.items():
                if json_key in parsed_data and parsed_data[json_key] and model_field:
                    value = parsed_data[json_key]
                    
                    # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ø–æ–ª–µ–π
                    if model_field == 'amount' and value:
                        try:
                            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ float, —É–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –∑–∞–ø—è—Ç—ã–µ
                            value = float(str(value).replace(',', '.').replace(' ', ''))
                            update_values[model_field] = value
                        except (ValueError, TypeError):
                            _logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—É–º–º—É: {value}")

                    elif model_field == 'currency' and value:
                        # –î–ª—è –ø–æ–ª—è –≤–∞–ª—é—Ç—ã –Ω—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∫–æ–¥
                        currency_mapping = {
                            'CNY': 'cny',
                            'USD': 'usd', 
                            'EUR': 'euro',
                            'EURO': 'euro',
                            'RUB': 'rub',
                            'AED': 'aed',
                            'THB': 'thb',
                            'IDR': 'idr',
                            'INR': 'inr',
                            'USDT': 'usdt'
                        }
                        currency_code = currency_mapping.get(str(value).upper(), str(value).lower())
                        update_values[model_field] = currency_code
                    
                    elif model_field == 'payment_date' and value:
                        # –î–ª—è –ø–æ–ª—è –¥–∞—Ç—ã –Ω—É–∂–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫—É –≤ –¥–∞—Ç—É
                        try:
                            from datetime import datetime
                            # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –¥–∞—Ç
                            date_formats = ['%Y-%m-%d', '%d.%m.%Y', '%d/%m/%Y', '%Y-%m-%d %H:%M:%S']
                            parsed_date = None
                            
                            date_str = str(value).strip()
                            for date_format in date_formats:
                                try:
                                    parsed_date = datetime.strptime(date_str, date_format).date()
                                    break
                                except ValueError:
                                    continue
                            
                            if parsed_date:
                                update_values[model_field] = parsed_date
                                _logger.info(f"–î–∞—Ç–∞ '{value}' –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∞ –≤ {parsed_date}")
                            else:
                                _logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã: {value}")
                        except Exception as e:
                            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞—Ç—ã '{value}': {str(e)}")
                    
                    else:
                        # –î–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–æ–ª–µ–π —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
                        update_values[model_field] = str(value)
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π Many2one –∏ Many2many
            self._handle_special_fields(parsed_data, update_values)

            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è, –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ –æ–±–Ω–æ–≤–ª—è—Ç—å
            if update_values:
                # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø–æ–ª—è –º–æ–¥–µ–ª–∏
                existing_fields = set(self._fields.keys())
                filtered_values = {k: v for k, v in update_values.items() if k in existing_fields}
                
                if filtered_values:
                    self.write(filtered_values)
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
                    updated_fields = ', '.join(f"{k}: {v}" for k, v in filtered_values.items())
                    _logger.info(f"‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø–æ–ª—è –∑–∞—è–≤–∫–∏ {self.zayavka_id}: {updated_fields}")
                else:
                    _logger.warning(f"–ù–∏ –æ–¥–Ω–æ –∏–∑ –ø–æ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –º–æ–¥–µ–ª–∏: {list(update_values.keys())}")
            else:
                _logger.info("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤ –æ—Ç–≤–µ—Ç–µ YandexGPT")
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª–µ–π –∏–∑ –æ—Ç–≤–µ—Ç–∞ YandexGPT: {str(e)}")

    def _handle_special_fields(self, parsed_data, update_values):
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π Many2one –∏ Many2many
        """
        try:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ country_id (Many2one –∫ amanat.country)
            if 'country_id' in parsed_data and parsed_data['country_id']:
                country_name = str(parsed_data['country_id']).strip().upper()
                
                # –ò—â–µ–º —Å—Ç—Ä–∞–Ω—É –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
                country = self.env['amanat.country'].search([
                    ('name', 'ilike', country_name)
                ], limit=1)
                
                if country:
                    update_values['country_id'] = country.id
                    _logger.info(f"–ù–∞–π–¥–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∞: {country.name} (ID: {country.id})")
                else:
                    _logger.warning(f"–°—Ç—Ä–∞–Ω–∞ '{country_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—è country_id")
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ subagent_payer_ids (Many2many –∫ amanat.payer)
            if 'subagent_payer_ids' in parsed_data and parsed_data['subagent_payer_ids']:
                payer_name = str(parsed_data['subagent_payer_ids']).strip()
                
                # –ò—â–µ–º –ø–ª–∞—Ç–µ–ª—å—â–∏–∫–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
                payer = self.env['amanat.payer'].search([
                    ('name', 'ilike', payer_name)
                ], limit=1)
                
                if payer:
                    # –û—á–∏—â–∞–µ–º –ø–æ–ª–µ subagent_payer_ids –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–≥–æ –ø–ª–∞—Ç–µ–ª—å—â–∏–∫–∞
                    update_values['subagent_payer_ids'] = [(6, 0, [payer.id])]  # (6, 0, ids) - –∑–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ –∑–∞–ø–∏—Å–∏
                    _logger.info(f"–û—á–∏—â–µ–Ω–æ –ø–æ–ª–µ subagent_payer_ids –∏ –¥–æ–±–∞–≤–ª–µ–Ω –ø–ª–∞—Ç–µ–ª—å—â–∏–∫ —Å—É–±–∞–≥–µ–Ω—Ç–∞: {payer.name} (ID: {payer.id})")
                    
                    # –¢–µ–ø–µ—Ä—å –∏—â–µ–º —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞ –¥–ª—è subagent_ids
                    if payer.contragents_ids:
                        # –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–≥–æ —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞
                        contragent = payer.contragents_ids[0]
                        # –û—á–∏—â–∞–µ–º –ø–æ–ª–µ subagent_ids –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–∞
                        update_values['subagent_ids'] = [(6, 0, [contragent.id])]  # (6, 0, ids) - –∑–∞–º–µ–Ω–∏—Ç—å –≤—Å–µ –∑–∞–ø–∏—Å–∏
                        _logger.info(f"–û—á–∏—â–µ–Ω–æ –ø–æ–ª–µ subagent_ids –∏ –¥–æ–±–∞–≤–ª–µ–Ω —Å–≤—è–∑–∞–Ω–Ω—ã–π —Å—É–±–∞–≥–µ–Ω—Ç: {contragent.name} (ID: {contragent.id})")
                    else:
                        _logger.warning(f"–£ –ø–ª–∞—Ç–µ–ª—å—â–∏–∫–∞ {payer.name} –Ω–µ—Ç —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç–æ–≤, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—è subagent_ids")
                        
                else:
                    _logger.warning(f"–ü–ª–∞—Ç–µ–ª—å—â–∏–∫ '{payer_name}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π subagent_payer_ids –∏ subagent_ids")
                        
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π: {str(e)}")                                   

    def get_screen_sber_images_base64(self):
        """
        –ü–æ–ª—É—á–∞–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ –ø–æ–ª—è screen_sber_attachments –∏ –∫–æ–¥–∏—Ä—É–µ—Ç –∏—Ö –≤ base64
        """
        try:
            images_data = []
            
            if not self.screen_sber_attachments:
                _logger.info("–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –ø–æ–ª–µ screen_sber_attachments")
                return images_data
            
            # –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
            supported_formats = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp']
            
            for attachment in self.screen_sber_attachments:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
                    if not attachment.mimetype or not attachment.mimetype.startswith('image/'):
                        _logger.warning(f"–§–∞–π–ª {attachment.name} –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º (mimetype: {attachment.mimetype})")
                        continue
                    
                    # –ü–æ–ª—É—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
                    file_extension = attachment.name.lower().split('.')[-1] if '.' in attachment.name else ''
                    if file_extension not in supported_formats:
                        _logger.warning(f"–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {file_extension} –¥–ª—è —Ñ–∞–π–ª–∞ {attachment.name}")
                        continue
                    
                    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª–∞
                    image_data = base64.b64decode(attachment.datas)
                    
                    # –ö–æ–¥–∏—Ä—É–µ–º –≤ base64 (–ø–æ–≤—Ç–æ—Ä–Ω–æ, —Ç–∞–∫ –∫–∞–∫ attachment.datas —É–∂–µ –≤ base64)
                    image_base64 = attachment.datas.decode('utf-8') if isinstance(attachment.datas, bytes) else attachment.datas
                    
                    images_data.append({
                        'name': attachment.name,
                        'mimetype': attachment.mimetype,
                        'size': len(image_data),
                        'base64': image_base64
                    })
                    
                    _logger.info(f"‚úÖ –ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ: {attachment.name} ({attachment.mimetype}, {len(image_data)} –±–∞–π—Ç)")
                    
                except Exception as e:
                    _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è {attachment.name}: {str(e)}")
                    continue
            
            _logger.info(f"üì∏ –í—Å–µ–≥–æ –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {len(images_data)}")
            return images_data
            
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π screen_sber: {str(e)}")
            return []

    def analyze_screen_sber_images_with_yandex_gpt(self):
        """
        –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–∑ screen_sber_attachments —Å –ø–æ–º–æ—â—å—é Yandex Vision OCR API
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ base64
            images_data = self.get_screen_sber_images_base64()
            
            if not images_data:
                _logger.info("üì∏ –ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –≤ screen_sber_attachments")
                return None
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            all_recognized_text = []
            
            for i, image_info in enumerate(images_data, 1):
                _logger.info(f"üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ {i}/{len(images_data)}: {image_info['name']}")
                
                recognized_text = self._send_image_to_yandex_gpt_vision(image_info)
                if recognized_text:
                    all_recognized_text.append({
                        'image_name': image_info['name'],
                        'recognized_text': recognized_text
                    })
                    _logger.info(f"‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–Ω —Ç–µ–∫—Å—Ç –∏–∑ {image_info['name']}:\n{recognized_text}")
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ YandexGPT –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                    _logger.info(f"ü§ñ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∏–∑ {image_info['name']} –≤ YandexGPT –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞...")
                    self._analyze_ocr_text_with_yandex_gpt(recognized_text, image_info['name'])
                    
                else:
                    _logger.warning(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–µ–∫—Å—Ç –∏–∑ {image_info['name']}")
            
            # –í—ã–≤–æ–¥–∏–º –æ–±—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            if all_recognized_text:
                _logger.info(f"–ò–¢–û–ì–û: –£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {len(all_recognized_text)} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")
                _logger.info("üìã –í—Å–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ—à–ª–∏ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª: OCR -> YandexGPT -> –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π –∑–∞—è–≤–∫–∏")
                for result in all_recognized_text:
                    _logger.info(f"üìÑ {result['image_name']}:\n{result['recognized_text']}\n" + "="*50)
            else:
                _logger.warning("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–µ–∫—Å—Ç –Ω–∏ –∏–∑ –æ–¥–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è")
                
            return all_recognized_text
            
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π screen_sber —Å Yandex Vision OCR: {str(e)}")
            
        return None

    def _send_image_to_yandex_gpt_vision(self, image_info):
        """
        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –æ–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ Yandex Vision OCR API –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
        """
        try:
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Api-Key {API_KEY}",
                "x-folder-id": FOLDER_ID,
                "x-data-logging-enabled": "true"
            }

            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è OCR API
            data = {
                "mimeType": image_info['mimetype'],
                "languageCodes": ["ru", "en"],
                "content": image_info['base64']
            }

            response = requests.post(
                url=OCR_URL, 
                headers=headers, 
                data=json.dumps(data), 
                timeout=60
            )
            
            if response.status_code == 200:
                result = response.json()
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∏–∑ –æ—Ç–≤–µ—Ç–∞ OCR API
                recognized_text = ""
                if 'result' in result and 'textAnnotation' in result['result']:
                    text_annotation = result['result']['textAnnotation']
                    if 'fullText' in text_annotation:
                        recognized_text = text_annotation['fullText']
                    elif 'blocks' in text_annotation:
                        # –ï—Å–ª–∏ fullText –Ω–µ—Ç, —Å–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ –±–ª–æ–∫–æ–≤
                        text_parts = []
                        for block in text_annotation['blocks']:
                            if 'lines' in block:
                                for line in block['lines']:
                                    if 'words' in line:
                                        line_words = []
                                        for word in line['words']:
                                            if 'text' in word:
                                                line_words.append(word['text'])
                                        if line_words:
                                            text_parts.append(' '.join(line_words))
                        recognized_text = '\n'.join(text_parts)
                
                return recognized_text.strip() if recognized_text else None
                
            else:
                _logger.error(f"–û—à–∏–±–∫–∞ API Yandex Vision OCR: {response.status_code} - {response.text}")
                return None
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Yandex Vision OCR: {str(e)}")
            return None

    def _analyze_ocr_text_with_yandex_gpt(self, recognized_text, image_name):
        """
        –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é YandexGPT
        """
        try:
            headers = {
                "Authorization": f"Api-Key {API_KEY}",
                "Content-Type": "application/json",
                "X-Folder-Id": FOLDER_ID
            }

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º
            user_message = f"–¢–µ–∫—Å—Ç, —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–π —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è '{image_name}':\n{recognized_text}"

            data = {
                "modelUri": f"gpt://{FOLDER_ID}/yandexgpt/latest",
                "completionOptions": {
                    "stream": False,
                    "temperature": 0.3,
                    "maxTokens": "2000"
                },
                "messages": [
                    {"role": "system", "text": PROMPT},
                    {"role": "user", "text": user_message}
                ]
            }

            response = requests.post(URL, headers=headers, json=data, timeout=30)
            
            if response.status_code == 200:
                result = response.json()
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
                if 'result' in result and 'alternatives' in result['result']:
                    alternatives = result['result']['alternatives']
                    if alternatives and len(alternatives) > 0:
                        gpt_response = alternatives[0]['message']['text']
                        
                        # –í—ã–≤–æ–¥–∏–º –æ—Ç–≤–µ—Ç –Ω–µ–π—Ä–æ–Ω–∫–∏ –≤ –ª–æ–≥–µ—Ä
                        _logger.info(f"ü§ñ YandexGPT –ê–ù–ê–õ–ò–ó –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø '{image_name}' –¥–ª—è –∑–∞—è–≤–∫–∏ {self.zayavka_id}:\n{gpt_response}")
                        
                        # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è –∑–∞—è–≤–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ –º–µ—Ç–æ–¥ —á—Ç–æ –∏ –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤)
                        self._update_fields_from_gpt_response(gpt_response)
                        
                        return gpt_response
                else:
                    _logger.warning(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞ –æ—Ç YandexGPT –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è '{image_name}': {result}")
            else:
                _logger.error(f"–û—à–∏–±–∫–∞ API YandexGPT –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è '{image_name}': {response.status_code} - {response.text}")
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è '{image_name}' —Å YandexGPT: {str(e)}")
            
        return None

    def get_excel_attachments(self):
        """
        –ü–æ–ª—É—á–∞–µ—Ç Excel —Ñ–∞–π–ª—ã –∏–∑ –≤—Å–µ—Ö –ø–æ–ª–µ–π –≤–ª–æ–∂–µ–Ω–∏–π –∑–∞—è–≤–∫–∏
        """
        try:
            excel_files = []
            
            # –°–ø–∏—Å–æ–∫ –ø–æ–ª–µ–π —Å –≤–ª–æ–∂–µ–Ω–∏—è–º–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ Excel —Ñ–∞–π–ª–æ–≤
            attachment_fields = [
                'zayavka_attachments',      # –ó–∞—è–≤–∫–∞ –í—Ö–æ–¥
            ]
            
            # –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã Excel
            excel_extensions = ['xls', 'xlsx', 'xlsm', 'csv']
            excel_mimetypes = [
                'application/vnd.ms-excel',
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'application/vnd.ms-excel.sheet.macroEnabled.12',
                'text/csv',
                'application/csv'
            ]
            
            for field_name in attachment_fields:
                if hasattr(self, field_name):
                    attachments = getattr(self, field_name)
                    if attachments:
                        for attachment in attachments:
                            try:
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
                                file_extension = attachment.name.lower().split('.')[-1] if '.' in attachment.name else ''
                                
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º mimetype
                                is_excel_by_mime = attachment.mimetype and any(
                                    mime in attachment.mimetype for mime in excel_mimetypes
                                )
                                
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
                                is_excel_by_ext = file_extension in excel_extensions
                                
                                if is_excel_by_mime or is_excel_by_ext:
                                    excel_files.append({
                                        'attachment': attachment,
                                        'field_name': field_name,
                                        'name': attachment.name,
                                        'mimetype': attachment.mimetype,
                                        'extension': file_extension,
                                        'size': len(base64.b64decode(attachment.datas)) if attachment.datas else 0
                                    })
                                    
                                    _logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω Excel —Ñ–∞–π–ª: {attachment.name} –≤ –ø–æ–ª–µ {field_name} "
                                               f"({attachment.mimetype}, {file_extension})")
                                    
                            except Exception as e:
                                _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–ª–æ–∂–µ–Ω–∏—è {attachment.name}: {str(e)}")
                                continue
            
            _logger.info(f"üìä –í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ Excel —Ñ–∞–π–ª–æ–≤: {len(excel_files)}")
            return excel_files
            
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ Excel —Ñ–∞–π–ª–æ–≤: {str(e)}")
            return []

    def _extract_text_from_excel(self, excel_file_info):
        """
        –ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏–∑ Excel —Ñ–∞–π–ª–∞
        """
        try:
            attachment = excel_file_info['attachment']
            file_name = excel_file_info['name']
            file_extension = excel_file_info['extension']
            
            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª–∞
            file_data = base64.b64decode(attachment.datas)
            file_buffer = io.BytesIO(file_data)
            
            extracted_text = []
            
            if file_extension == 'csv':
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ CSV —Ñ–∞–π–ª–æ–≤
                try:
                    # –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏
                    for encoding in ['utf-8', 'cp1251', 'iso-8859-1']:
                        try:
                            file_buffer.seek(0)
                            df = pd.read_csv(file_buffer, encoding=encoding)
                            break
                        except UnicodeDecodeError:
                            continue
                    else:
                        # –ï—Å–ª–∏ –≤—Å–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –Ω–µ –ø–æ–¥–æ—à–ª–∏
                        file_buffer.seek(0)
                        df = pd.read_csv(file_buffer, encoding='utf-8')
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ –≤—Å–µ—Ö —è—á–µ–µ–∫
                    for col in df.columns:
                        extracted_text.append(f"–ö–æ–ª–æ–Ω–∫–∞: {col}")
                        for value in df[col].dropna():
                            if pd.notna(value) and str(value).strip():
                                extracted_text.append(str(value).strip())
                                
                except Exception as e:
                    _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ CSV —Ñ–∞–π–ª–∞ {file_name}: {str(e)}")
                    return None
                    
            else:
                # –û–±—Ä–∞–±–æ—Ç–∫–∞ Excel —Ñ–∞–π–ª–æ–≤ (.xlsx, .xls, .xlsm)
                try:
                    # –ß–∏—Ç–∞–µ–º –≤—Å–µ –ª–∏—Å—Ç—ã Excel —Ñ–∞–π–ª–∞
                    if file_extension in ['xlsx', 'xlsm']:
                        excel_file = pd.ExcelFile(file_buffer, engine='openpyxl')
                    else:  # .xls
                        excel_file = pd.ExcelFile(file_buffer, engine='xlrd')
                    
                    sheet_names = excel_file.sheet_names
                    _logger.info(f"üìÑ –õ–∏—Å—Ç—ã –≤ —Ñ–∞–π–ª–µ {file_name}: {sheet_names}")
                    
                    for sheet_name in sheet_names:
                        try:
                            # –ß–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å –ª–∏—Å—Ç–∞
                            df = pd.read_excel(excel_file, sheet_name=sheet_name)
                            
                            extracted_text.append(f"\n=== –õ–ò–°–¢: {sheet_name} ===")
                            
                            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∫–æ–ª–æ–Ω–æ–∫
                            if not df.empty:
                                headers = [str(col) for col in df.columns if str(col) != 'Unnamed']
                                if headers:
                                    extracted_text.append(f"–ó–∞–≥–æ–ª–æ–≤–∫–∏: {', '.join(headers)}")
                                
                                # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö —è—á–µ–µ–∫
                                for index, row in df.iterrows():
                                    row_data = []
                                    for col in df.columns:
                                        value = row[col]
                                        if pd.notna(value) and str(value).strip() and str(value) != 'nan':
                                            row_data.append(str(value).strip())
                                    
                                    if row_data:  # –ï—Å–ª–∏ –≤ —Å—Ç—Ä–æ–∫–µ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
                                        extracted_text.append(f"–°—Ç—Ä–æ–∫–∞ {index + 1}: {' | '.join(row_data)}")
                            else:
                                extracted_text.append("–õ–∏—Å—Ç –ø—É—Å—Ç–æ–π")
                                
                        except Exception as e:
                            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –ª–∏—Å—Ç–∞ '{sheet_name}' –∏–∑ —Ñ–∞–π–ª–∞ {file_name}: {str(e)}")
                            extracted_text.append(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ª–∏—Å—Ç–∞ '{sheet_name}': {str(e)}")
                            continue
                            
                except Exception as e:
                    _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ Excel —Ñ–∞–π–ª–∞ {file_name}: {str(e)}")
                    return None
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤–µ—Å—å —Ç–µ–∫—Å—Ç
            full_text = '\n'.join(extracted_text)
            
            if full_text.strip():
                _logger.info(f"‚úÖ –ò–∑–≤–ª–µ—á–µ–Ω —Ç–µ–∫—Å—Ç –∏–∑ {file_name}: {len(full_text)} —Å–∏–º–≤–æ–ª–æ–≤")
                _logger.info(f"üìã –ü–µ—Ä–≤—ã–µ 200 —Å–∏–º–≤–æ–ª–æ–≤: {full_text[:200]}...")
                return full_text
            else:
                _logger.warning(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏–∑ {file_name} - —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π")
                return None
                
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞ –∏–∑ Excel —Ñ–∞–π–ª–∞ {excel_file_info['name']}: {str(e)}")
            return None

    def analyze_excel_documents(self):
        """
        –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç Excel –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏–∑ –≤–ª–æ–∂–µ–Ω–∏–π –∑–∞—è–≤–∫–∏
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º Excel —Ñ–∞–π–ª—ã
            excel_files = self.get_excel_attachments()
            
            if not excel_files:
                _logger.info("üìä –ù–µ—Ç Excel —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –≤ –∑–∞—è–≤–∫–µ")
                return None
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π Excel —Ñ–∞–π–ª
            all_extracted_data = []
            
            for i, excel_file_info in enumerate(excel_files, 1):
                _logger.info(f"üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º Excel —Ñ–∞–π–ª {i}/{len(excel_files)}: {excel_file_info['name']}")
                _logger.info(f"üìÇ –ü–æ–ª–µ: {excel_file_info['field_name']}")
                _logger.info(f"üìÑ –†–∞–∑–º–µ—Ä: {excel_file_info['size']} –±–∞–π—Ç")
                _logger.info(f"üîß –¢–∏–ø: {excel_file_info['mimetype']} (.{excel_file_info['extension']})")
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ Excel —Ñ–∞–π–ª–∞
                extracted_text = self._extract_text_from_excel(excel_file_info)
                
                if extracted_text:
                    all_extracted_data.append({
                        'file_name': excel_file_info['name'],
                        'field_name': excel_file_info['field_name'],
                        'file_size': excel_file_info['size'],
                        'extension': excel_file_info['extension'],
                        'extracted_text': extracted_text,
                        'text_length': len(extracted_text)
                    })
                    
                    # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    _logger.info(f"‚úÖ –£—Å–ø–µ—à–Ω–æ –∏–∑–≤–ª–µ—á–µ–Ω —Ç–µ–∫—Å—Ç –∏–∑ {excel_file_info['name']}")
                    _logger.info(f"üìä –î–ª–∏–Ω–∞ –∏–∑–≤–ª–µ—á–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞: {len(extracted_text)} —Å–∏–º–≤–æ–ª–æ–≤")
                    
                    # –í—ã–≤–æ–¥–∏–º –ø–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç –≤ –ª–æ–≥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
                    _logger.info(f"üìã –ü–û–õ–ù–´–ô –¢–ï–ö–°–¢ –ò–ó –§–ê–ô–õ–ê '{excel_file_info['name']}':")
                    _logger.info("=" * 80)
                    _logger.info(extracted_text)
                    _logger.info("=" * 80)
                    
                else:
                    _logger.warning(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –∏–∑ {excel_file_info['name']}")
            
            # –í—ã–≤–æ–¥–∏–º –æ–±—â—É—é —Å–≤–æ–¥–∫—É
            if all_extracted_data:
                _logger.info("üéâ –ê–ù–ê–õ–ò–ó EXCEL –î–û–ö–£–ú–ï–ù–¢–û–í –ó–ê–í–ï–†–®–ï–ù")
                _logger.info(f"üìä –í—Å–µ–≥–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: {len(all_extracted_data)}")
                _logger.info("üìã –°–í–û–î–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í:")
                
                total_text_length = 0
                for i, data in enumerate(all_extracted_data, 1):
                    total_text_length += data['text_length']
                    _logger.info(f"  {i}. {data['file_name']} ({data['extension'].upper()})")
                    _logger.info(f"     –ü–æ–ª–µ: {data['field_name']}")
                    _logger.info(f"     –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞: {data['file_size']} –±–∞–π—Ç")
                    _logger.info(f"     –ò–∑–≤–ª–µ—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–∞: {data['text_length']} —Å–∏–º–≤–æ–ª–æ–≤")
                
                _logger.info(f"üìà –û–±—â–∏–π –æ–±—ä–µ–º –∏–∑–≤–ª–µ—á–µ–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞: {total_text_length} —Å–∏–º–≤–æ–ª–æ–≤")
                _logger.info("‚úÖ –í—Å–µ Excel —Ñ–∞–π–ª—ã —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã!")
                
                # –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –∑–¥–µ—Å—å –≤ –±—É–¥—É—â–µ–º –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É –≤ YandexGPT
                _logger.info("üí° –ü–†–ò–ú–ï–ß–ê–ù–ò–ï: –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ YandexGPT –ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ (–ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é)")
                _logger.info("üí° –î–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –∞–Ω–∞–ª–∏–∑–∞ YandexGPT —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –∫–æ–¥ –Ω–∏–∂–µ:")
                _logger.info("üí° # for data in all_extracted_data:")
                _logger.info("üí° #     self.analyze_document_with_yandex_gpt(data['extracted_text'])")
                
            else:
                _logger.warning("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Ç–µ–∫—Å—Ç –Ω–∏ –∏–∑ –æ–¥–Ω–æ–≥–æ Excel —Ñ–∞–π–ª–∞")
                
            return all_extracted_data
            
        except Exception as e:
            _logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ Excel –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤: {str(e)}")
            
        return None
